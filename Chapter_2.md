# 变量和基本类型

## 基本内置类型

1. 算术类型的尺寸在不同机器上有所差别，其尺寸的最小值如下：
    | 数据类型 | 尺寸 |
    |---|---|
    | bool | 未定义 |
    | char | 8位 |
    | wchar_t | 16位 |
    | char_t | 16位 |
    | char16_t | 16位 |
    | char32_t | 32位 |
    | short | 16位 |
    | int | 16位 |
    | long | 32位 |
    | long long | 64位 |
    | float | 6位有效数字 |
    | double | 10位有效数字 |
    | long double | 10位有效数字 |
2. 大多数机器的字节由`8`比特构成，字则由`32`或`64`比特构成，也就是`4`或`8`字节。
3. `char`与`signed char`并不一样，字符的表现形式只有带符号的和无符号的。`char`会表现为其中一种，由编译器决定。
4. 明确知晓数值不可能为负时，选用无符号类型。
5. 整数运算一般选用`int`，若数值超过范围选用`long long`。 
6. 浮点数运算选用`double`，`float`运算代价与`double`差不了太多。

## 变量

1. `对象`指一块能存储数据并具有某种类型的内存空间。
2. 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。
3. `声明`使得名字为程序所知，而`定义`负责创建与名字关联的实体。 
4. `extern`关键字用于声明变量而非定义它。
5. 当你第一次使用变量时再定义它，在对象被使用的地方附近定义它有助于更容易地找到变量的定义。

## 复合类型

1. `复合类型`是指基于其他类型定义的类型，例如`引用`和`指针`。
2. `引用`即别名，它只是为一个已经存在的对象所起的另外一个名字。
3. 定义引用时，程序将其与初始值绑定在一起，因此引用必须初始化。
4. 引用必须绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。
5. `指针`是指向另外一种类型的复合类型。
6. 指针存放某个对象的地址，要想获取该地址，需要使用`取地址符`（操作符&）。
7. 如果指针指向了一个对象，则允许使用`解引用符`（操作符*）来访问该对象。
8. 空指针不指向任何对象，生成空指针方法如下：
    ```
    int *p1 = nullptr;
    int *p2 = 0;
    int *p3 = NULL;
    ```
9. 一旦定义了引用，就无法令其再绑定到另外的对象。
10. `void*`是一种特殊的指针类型，可用于存放任意对象的地址。
11. 变量的定义包括一个基本数据类型和一组声明符。
    ```
    int i = 1024, *p = &i, &r = i;  // int是基本数据类型，* 和 & 是类型修饰符，*p 和 &r 是声明符 
    ```

## const限定符

1. `const`对象一旦创建后其值就就不能再改变，所以`const`对象必须初始化。
2. 默认状态下，`const`对象仅在文件内有效，除非进行了引入。
3. 为了让变量在不引入时也能共享于文件间，可以添加`extern`关键字：
    ```
    // file_1.cc
    extern const int bufsize = fcn();
    // file_1.h
    extern const int bufsize;
    ```
4. 对常量的引用不能被用作修改它所绑定的对象。
5. 基于4，初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。 
6. 指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。
7. 指向常量的指针： ```const int *p```，所指对象的值不能改变。
8. 即常量指针：```int *const p```，所指地址不能改变。
9. 顶层`const`表示指针本身是个常量。
    ```
    int i = 0;
    int *const p1 = &i;  // 不能改变p1的值
    const int ci = 42;  // 不能改变ci的值
    ```
10. 底层`const`表示指针所指的对象是一个常量。 
    ```
    const int *p2 = &ci;  // 不能改变p2所指对象ci的值，可以改变p2的值
    const int &r = ci;  // 不能改变r所指对象ci的值
    ```
11. 当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层`const`资格，或者两个对象的数据类型必须能够转换。
12. 常量表达式`constexpr`是指不会改变并且在编译过程就能得到计算结果的表达式。 
13. 一个`constexpr`指针的初始值必须是nullptr或者0，或者时存储于某个固定地址中的对象。

## 处理类型

1. `类型别名`是一个名字，它是某种类型的同义词。
2. 使用关键字`typedef`或别名声明`using`可以定义类型别名。
3. `auto`类型说明符能够让编译器替我们去分析表达式所属的类型。
4. `decltype`类型说明符能够选择并返回操作数的数据类型。
    ```
    int i = 42, *p = &i;
    decltype(*p) c;  // 错误：c是int&，必须初始化
    ```
5. 如果`decltype`使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。
    ```
    decltype((i)) d;  // 错误：d是int&，必须初始化
    ```
    
## 自定义数据结构

1. 结构体`struct`：
    ```
    struct Sales_data {
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
    }
    ```
2. 为了确保各个文件中类的定义一致，类通常被定义在头文件中。
3. 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。
4. `预处理器`是在编译之前执行的一段程序。
5. `头文件保护符`依赖于预处理变量`#define`、`#ifdef`和`#ifndef`，一但检查结果为真，则执行后续操作直至遇到`#endif`指令为止。